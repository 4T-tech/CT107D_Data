C51 COMPILER V9.56.0.0   MAIN                                                              01/25/2025 16:43:25 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEFINE(PCF8591) DEBUG 
                    -OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #define test
   2          
   3          #include "tim.h"
   4          #include "seg.h"
   5          #include <stdio.h>
   6          #include "key.h"
   7          #include "uart.h"
   8          #include "i2c.h"
   9          #include "math.h"
  10          
  11          unsigned int  uiSec;                  // 秒值
  12          unsigned char ucState;                // 系统状态
  13          unsigned char ucSdev;                 // 设备状态：
  14          // 0-空闲状态, 1-运行准备, 2-运行处理, 3-运行结束, 4-等待状态
  15          unsigned int  idata uiCstaX;          // 起始X坐标
  16          unsigned int  idata uiCstaY;          // 起始Y坐标
  17          unsigned int  idata uiCtarX;          // 目的X坐标
  18          unsigned int  idata uiCtarY;          // 目的Y坐标
  19          unsigned int  idata uiCdevX;          // 设备X位置
  20          unsigned int  idata uiCdevY;          // 设备Y位置
  21          unsigned int  idata uiSpeed;          // 行进速度*10
  22          unsigned char ucScen;                 // 场景
  23          unsigned char ucR=10;                 // 参数R*10
  24            signed char scB;                    // 参数B
  25          unsigned char ucDist;                 // 障碍物距离
  26                      bit bRun;                   // 运行标志
  27          
  28          void Seg_Proc(void);
  29          void Key_Proc(void);
  30          void Led_Proc(void);
  31          void Uart_Proc(void);
  32          void Data_Proc(void);
  33          // 主函数
  34          void main(void)
  35          {
  36   1        Close_Peripheral();
  37   1        T1_Init();
  38   1        Uart_Init();
  39   1        T0_Init();
  40   1      
  41   1        while (1)
  42   1        {
  43   2          Seg_Proc();
  44   2          Key_Proc();
  45   2          Led_Proc();
  46   2          Uart_Proc();
  47   2          Data_Proc();
  48   2        }
  49   1      }
  50          
  51          unsigned char pucSeg_Char[12];        // 显示字符
  52          unsigned char pucSeg_Code[8];         // 显示代码
  53          unsigned char ucSeg_Pos;              // 显示位置
  54          unsigned int  uiSeg_Dly;              // 显示刷新延时
C51 COMPILER V9.56.0.0   MAIN                                                              01/25/2025 16:43:25 PAGE 2   

  55          unsigned char ucSeg_Dly;              // 显示移位延时
  56          void Seg_Proc(void)
  57          {
  58   1        if (uiSeg_Dly > 300)                // 300ms刷新1次
  59   1        {
  60   2          uiSeg_Dly = 0;
  61   2      
  62   2          switch (ucState)
  63   2          {
  64   3            case 0:                         // 坐标界面
  65   3      #ifndef test
                      if (ucSdev == 0)              // 空闲状态显示设备坐标
              #else
  68   3              if (ucSdev == 2)              // 运行状态显示设备坐标
  69   3      #endif
  70   3                sprintf(pucSeg_Char, "L%3u-%3u", uiCdevX, uiCdevY);
  71   3              else                          // 其他状态显示目的坐标
  72   3                sprintf(pucSeg_Char, "L%3u-%3u", uiCtarX, uiCtarY);
  73   3              break;
  74   3            case 1:                         // 速度界面
  75   3              switch (ucSdev)
  76   3              {
  77   4                case 2:                     // 运行处理显示速度
  78   4                  sprintf(pucSeg_Char, "E1 %4u.%1u", uiSpeed/10, uiSpeed%10);
  79   4                  break;
  80   4                case 0:                     // 空闲状态
  81   4      #ifndef test
                          sprintf(pucSeg_Char, "E2 -----");
              #else
  84   4                  sprintf(pucSeg_Char, "E2 %4u.%1u", uiSpeed/10, uiSpeed%10);
  85   4      #endif
  86   4                  break;
  87   4                case 4:                     // 等待状态显示距离
  88   4      #ifndef test
                          sprintf(pucSeg_Char, "E3 %5u", (int)ucDist);
              #else
  91   4                  sprintf(pucSeg_Char, "E3 %1u %3u", (int)ucScen, (int)ucDist);
  92   4      #endif
  93   4              }
  94   3              break;
  95   3            case 2:                         // 参数界面（R参数有效）
  96   3            case 3:                         // 参数界面（B参数有效）
  97   3              sprintf(pucSeg_Char, "P %2.1f %3d", ucR/10.0, (int)scB);
  98   3          }
  99   2          Seg_Tran(pucSeg_Char, pucSeg_Code);
 100   2        }
 101   1      }
 102          
 103          unsigned char ucKey_Old;              // 旧键值
 104          unsigned char ucKey_Dly;              // 按键刷新延时
 105          void Key_Proc(void)
 106          {
 107   1        unsigned char ucKey_Dn;             // 按下键值
 108   1      
 109   1        if(ucKey_Dly < 10)                  // 延时10ms消抖
 110   1          return;
 111   1        ucKey_Dly = 0;
 112   1      
 113   1        ucKey_Dn = Key_Read();              // 键值读取
 114   1        if (ucKey_Dn != ucKey_Old)          // 键值变化
 115   1        {
 116   2          ucKey_Old = ucKey_Dn;
C51 COMPILER V9.56.0.0   MAIN                                                              01/25/2025 16:43:25 PAGE 3   

 117   2        } else {
 118   2          ucKey_Dn = 0;
 119   2        }
 120   1      
 121   1        switch (ucKey_Dn)
 122   1        {
 123   2          case 4:                           // S4按键按下
 124   2            switch (ucSdev)
 125   2            {
 126   3              case 0:                       // 空闲状态
 127   3                if (bRun)                   // 有坐标数据
 128   3                  ucSdev = 1;               // 运行准备
 129   3                break;
 130   3              case 2:                       // 运行处理
 131   3                ucSdev = 4;                 // 等待状态
 132   3                break;
 133   3              case 4:                       // 等待状态
 134   3                if (ucDist > 30)
 135   3                  ucSdev = 2;               // 运行处理
 136   3            }
 137   2            break;
 138   2          case 5:                           // S5按键按下
 139   2            if (ucSdev == 0)                // 空闲状态
 140   2            {
 141   3              uiCstaX = uiCstaY = 0;        // 重置起始坐标
 142   3              uiCdevX = uiCdevY = 0;        // 重置设备坐标
 143   3            }
 144   2            break;
 145   2          case 8:                           // S8按键按下
 146   2            if (++ucState >= 3)             // 切换界面
 147   2              ucState = 0;
 148   2            break;
 149   2          case 9:                           // S9按键按下
 150   2            if ((ucState == 2) || (ucState == 3)) // 参数界面
 151   2              ucState ^= 1;
 152   2            if (ucState == 1)               // 速度界面
 153   2              ucSdev ^= 4;                  // 切换设备状态（测试用）
 154   2            break;
 155   2          case 12:                          // S9按键按下
 156   2            if (ucState == 2)               // R参数
 157   2            {
 158   3              if (ucR < 20)
 159   3                ucR++;                      // 调整R参数
 160   3            }
 161   2            else if (ucState == 3)          // B参数
 162   2              if (scB < 90)
 163   2                scB += 5;                   // 调整B参数
 164   2            break;
 165   2          case 13:                          // S9按键按下
 166   2            if (ucState == 2)               // R参数
 167   2            {
 168   3              if (ucR > 10)
 169   3                ucR--;                      // 调整R参数
 170   3            }
 171   2            else if (ucState == 3)          // B参数
 172   2              if (scB > -90)
 173   2                scB -= 5;                   // 调整B参数
 174   2        }
 175   1      }
 176          
 177          unsigned char ucLed;                  // LED值
 178          unsigned char ucLed_Dly;              // LED延时
C51 COMPILER V9.56.0.0   MAIN                                                              01/25/2025 16:43:25 PAGE 4   

 179          void Led_Proc(void)
 180          {
 181   1        if(ucLed_Dly < 100)                 // 延时100ms
 182   1          return;
 183   1        ucLed_Dly = 0;
 184   1      
 185   1        switch (ucSdev)
 186   1        {
 187   2          case 0:                           // 空闲状态
 188   2          case 3:
 189   2            ucLed &= ~1;                    // L1熄灭
 190   2            break;
 191   2          case 2:                           // 运行状态
 192   2            ucLed |= 1;                     // L1点亮
 193   2            break;
 194   2          case 4:                           // 等待状态
 195   2            ucLed ^= 1;                     // L1闪烁
 196   2        }
 197   1      
 198   1        if ((ucSdev == 2) && (ucScen == 0)) // 夜间行进
 199   1          ucLed |= 2;                       // L2点亮
 200   1        else
 201   1          ucLed &= ~2;                      // L2熄灭
 202   1      
 203   1        if (ucSdev == 3)                    // 运行结束
 204   1        {
 205   2          if (uiSec < 3)
 206   2            ucLed |= 4;                     // L3点亮
 207   2          else
 208   2          {
 209   3            ucLed &= ~4;                    // L3熄灭
 210   3            ucSdev = 0;
 211   3            bRun = 0;
 212   3          }
 213   2        }
 214   1        Led_Disp(ucLed);
 215   1      
 216   1        if (ucSdev == 2)                    // 运行状态
 217   1          Uln_Ctrl(0x10);                   // 继电器吸合
 218   1        else
 219   1          Uln_Ctrl(0);                      // 继电器断开
 220   1      }
 221          
 222          unsigned int  uiUsec;                 // UART发送延时
 223          unsigned char pucUart_Buf[10];        // UART接收值
 224          unsigned char ucUart_Num;             // 串行口接收字符计数
 225          //unsigned char pucUart_Buf[10] = {"(130,420)"};  // UART接收值
 226          //unsigned char ucUart_Num=0x89;      // 串行口接收字符计数（9个字符）
 227          void Uart_Proc(void)
 228          {
 229   1        unsigned char i, m, n;
 230   1        unsigned int  c[2];
 231   1      
 232   1        if (uiUsec != uiSec)                // 测试用
 233   1        {
 234   2          uiUsec = uiSec;
 235   2      #ifdef test
 236   2          printf("%03u\r\n", uiSec);
 237   2      #endif
 238   2        }
 239   1      
 240   1        Uart_RecvString();
C51 COMPILER V9.56.0.0   MAIN                                                              01/25/2025 16:43:25 PAGE 5   

 241   1        if (ucUart_Num <= 0x80)             // 接收未完成
 242   1          return;
 243   1        if (ucUart_Num == 0x81)             // ?或#
 244   1        {
 245   2          if (pucUart_Buf[0] == '?')        // 查询设备状态
 246   2            switch (ucSdev)
 247   2            {
 248   3              case 0:
 249   3                printf("Idle");
 250   3                break;
 251   3              case 2:
 252   3                printf("Busy");
 253   3                break;
 254   3              case 4:
 255   3                printf("Wait");
 256   3            }
 257   2          else if (pucUart_Buf[0] == '#')   // 查询设备位置
 258   2            printf("(%u,%u)", uiCdevX, uiCdevY);
 259   2          else
 260   2            printf("Error");
 261   2        } else if (pucUart_Buf[0] == '(')   // 设置目的地坐标
 262   1        {
 263   2          m = 0;
 264   2          n = 0;
 265   2          ucUart_Num -= 0x81;
 266   2          for (i=1; i<=ucUart_Num; i++)     // 解析数据
 267   2          {
 268   3            if ((pucUart_Buf[i] == ',') || (pucUart_Buf[i] == ')'))
 269   3            {
 270   4              c[n] = 0;
 271   4              switch (i-m-1)                // 数据位数
 272   4              {
 273   5                case 3:
 274   5                  c[n] += (pucUart_Buf[i-3]-'0')*100;
 275   5                case 2:
 276   5                  c[n] += (pucUart_Buf[i-2]-'0')*10;
 277   5                case 1:
 278   5                  c[n] += pucUart_Buf[i-1]-'0';
 279   5              }
 280   4              m = i;
 281   4              n++;
 282   4            }
 283   3          }
 284   2          if ((n == 2) && (ucSdev == 0))
 285   2          {
 286   3            uiCtarX = c[0];                 // 目的X坐标
 287   3            uiCtarY = c[1];                 // 目的Y坐标
 288   3            printf("Got it");
 289   3            bRun = 1;
 290   3          } else
 291   2            printf("Busy");
 292   2        }
 293   1        else
 294   1          printf("Error");
 295   1        ucUart_Num = 0;
 296   1      }
 297          
 298          char putchar(char c)
 299          {
 300   1        Uart_SendChar(c);
 301   1        return c;
 302   1      }
C51 COMPILER V9.56.0.0   MAIN                                                              01/25/2025 16:43:25 PAGE 6   

 303          
 304          unsigned char ucData_Dly;             // 数据采集计时
 305          unsigned int  uiFreq;                 // 频率值
 306            signed int  siDistX;                // 距离X
 307            signed int  siDistY;                // 距离Y
 308          unsigned int  uiDist;                 // 距离*10
 309          unsigned int  uiDcur;                 // 当前距离*10
 310          void Data_Proc(void)                  // 数据处理
 311          {
 312   1        float fProg;
 313   1      
 314   1        if (ucData_Dly < 100)               // 100ms未到
 315   1          return;
 316   1        ucData_Dly = 0;
 317   1      
 318   1        if (ucSdev == 1)                    // 运行准备
 319   1        {
 320   2          siDistX = uiCtarX-uiCstaX;
 321   2          siDistY = uiCtarY-uiCstaY;
 322   2          uiDist = sqrt(pow(siDistX, 2)+pow(siDistY, 2)) * 10;
 323   2          uiDcur = 0;
 324   2          ucSdev = 2;                       // 运行处理
 325   2        }
 326   1      
 327   1        uiSpeed = 3.14*ucR*uiFreq/100+scB*10;   // 速度*10
 328   1        if (ucSdev == 2)                    // 运行处理
 329   1        {
 330   2          if (uiSpeed > 0)
 331   2          {
 332   3            uiDcur += uiSpeed / 10;         // 100ms运行距离: (usSpeed/10)*0.1s*10
 333   3            if (uiDcur < uiDist)
 334   3            {                               // 按比例计算当前位置
 335   4              fProg = (float)uiDist/uiDcur;
 336   4              uiCdevX = siDistX/fProg+uiCstaX;
 337   4              uiCdevY = siDistY/fProg+uiCstaY;
 338   4            } else {
 339   4              uiCstaX = uiCtarX;
 340   4              uiCstaY = uiCtarY;
 341   4              uiCdevX = uiCtarX;
 342   4              uiCdevY = uiCtarY;
 343   4              ucSdev = 3;                   // 运行结束
 344   4              uiSec = 0;
 345   4            }
 346   3          }
 347   2        }
 348   1      
 349   1        ucDist = Dist_Meas();
 350   1        if ((ucDist < 30) && (ucSdev == 2))
 351   1          ucSdev = 4;                       // 等待状态
 352   1      
 353   1        if (PCF8591_Adc(1)*10/51 > 12)
 354   1          ucScen = 1;                       // 日间场景
 355   1        else
 356   1          ucScen = 0;                       // 夜间场景
 357   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1602    ----
   CONSTANT SIZE    =     97    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.56.0.0   MAIN                                                              01/25/2025 16:43:25 PAGE 7   

   DATA SIZE        =     60       9
   IDATA SIZE       =     14    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
