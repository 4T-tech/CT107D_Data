C51 COMPILER V9.56.0.0   I2C                                                               01/25/2025 07:31:09 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\Objects\i2c.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\Driver\i2c.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEFINE(AT24C0
                    -2) DEBUG OBJECTEXTEND PRINT(.\Listings\i2c.lst) TABS(2) OBJECT(.\Objects\i2c.obj)

line level    source

   1          #define DELAY_TIME 5
   2          // I2C引脚定义
   3          sfr  P2 = 0xA0;
   4          sbit SCL = P2^0;                // 时钟线
   5          sbit SDA = P2^1;                // 数据线
   6          
   7          void I2C_Delay(unsigned char i)
   8          {
   9   1        while(i--);
  10   1      }
  11          // I2C起始条件
  12          void I2C_Start(void)
  13          {
  14   1        SDA = 1;
  15   1        SCL = 1;
  16   1        I2C_Delay(DELAY_TIME);
  17   1        SDA = 0;
  18   1        I2C_Delay(DELAY_TIME);
  19   1      }
  20          // I2C停止条件
  21          void I2C_Stop(void)
  22          {
  23   1        SDA = 0;
  24   1        SCL = 1;
  25   1        I2C_Delay(DELAY_TIME);
  26   1        SDA = 1;
  27   1        I2C_Delay(DELAY_TIME);
  28   1      }
  29          // I2C发送应答：0-应答，1-非应答
  30          void I2C_SendAck(bit bAck)
  31          {
  32   1        SCL = 0;
  33   1        SDA = bAck;
  34   1        I2C_Delay(DELAY_TIME);
  35   1        SCL = 1;
  36   1        I2C_Delay(DELAY_TIME);
  37   1        SCL = 0; 
  38   1        SDA = 1;
  39   1        I2C_Delay(DELAY_TIME);
  40   1      }
  41          // I2C等待应答
  42          bit I2C_WaitAck(void)
  43          {
  44   1        bit bAck;
  45   1      
  46   1        SCL  = 1;
  47   1        I2C_Delay(DELAY_TIME);
  48   1        bAck = SDA;
  49   1        SCL = 0;
  50   1        I2C_Delay(DELAY_TIME);
  51   1        return bAck;
  52   1      }
  53          // I2C发送数据
  54          void I2C_SendByte(unsigned char ucData)
C51 COMPILER V9.56.0.0   I2C                                                               01/25/2025 07:31:09 PAGE 2   

  55          {
  56   1        unsigned char i;
  57   1      
  58   1        for (i=0; i<8; i++)
  59   1        {
  60   2          SCL  = 0;
  61   2          I2C_Delay(DELAY_TIME);
  62   2          if (ucData & 0x80)
  63   2            SDA  = 1;
  64   2          else
  65   2            SDA  = 0;
  66   2          I2C_Delay(DELAY_TIME);
  67   2          SCL = 1;
  68   2          ucData <<= 1;
  69   2          I2C_Delay(DELAY_TIME);
  70   2        }
  71   1        SCL  = 0;
  72   1      }
  73          // I2C接收数据
  74          unsigned char I2C_RecvByte(void)
  75          {
  76   1        unsigned char i, ucData;
  77   1      
  78   1        for (i=0; i<8; i++)
  79   1        {
  80   2          SCL = 1;
  81   2          I2C_Delay(DELAY_TIME);
  82   2          ucData <<= 1;
  83   2          if (SDA)
  84   2            ucData |= 1;
  85   2          SCL = 0;
  86   2          I2C_Delay(DELAY_TIME);
  87   2        }
  88   1        return ucData;
  89   1      }
  90          #ifdef AT24C02
  91          // AT24C02缓存器写：pucBuf-数据，ucAddr-地址，ucNum-数量
  92          void AT24C02_WriteBuffer(unsigned char *pucBuf,
  93            unsigned char ucAddr, unsigned char ucNum)
  94          {
  95   1        I2C_Start();
  96   1        I2C_SendByte(0xa0);           // 发送器件地址及控制位（写）
  97   1        I2C_WaitAck();
  98   1      
  99   1        I2C_SendByte(ucAddr);         // 发送数据地址
 100   1        I2C_WaitAck();
 101   1      
 102   1        while (ucNum--)
 103   1        {
 104   2          I2C_SendByte(*pucBuf++);    // 发送数据
 105   2          I2C_WaitAck();
 106   2          I2C_Delay(200);
 107   2        }
 108   1        I2C_Stop();
 109   1      }
 110          // AT24C02缓存器读：pucBuf-数据，ucAddr-地址，ucNum-数量
 111          void AT24C02_ReadBuffer(unsigned char *pucBuf,
 112            unsigned char ucAddr, unsigned char ucNum)
 113          {
 114   1        I2C_Start();
 115   1        I2C_SendByte(0xa0);           // 发送器件地址及控制位（写）
 116   1        I2C_WaitAck();
C51 COMPILER V9.56.0.0   I2C                                                               01/25/2025 07:31:09 PAGE 3   

 117   1      
 118   1        I2C_SendByte(ucAddr);         // 发送数据地址
 119   1        I2C_WaitAck();
 120   1      
 121   1        I2C_Start();
 122   1        I2C_SendByte(0xa1);         // 发送器件地址及控制位（读）
 123   1        I2C_WaitAck();
 124   1      
 125   1        while (ucNum--)
 126   1        {
 127   2          *pucBuf++ = I2C_RecvByte();     // 接收数据
 128   2          if (ucNum)
 129   2            I2C_SendAck(0);
 130   2          else
 131   2            I2C_SendAck(1);
 132   2        }
 133   1        I2C_Stop();
 134   1      }
 135          #endif
 136          #ifdef PCF8591
              // PCF8591 ADC：ucAin-ADC通道（0~3），返回值-ADC值
              unsigned char PCF8591_Adc(unsigned char ucAin)
              {
                unsigned char ucAdc;
              
                I2C_Start();
                I2C_SendByte(0x90);           // 发送器件地址及控制位（写）
                I2C_WaitAck();
              
                I2C_SendByte(ucAin + 0x40); // 发送控制字（ADC通道，允许DAC）
                I2C_WaitAck();
              
                I2C_Start();
                I2C_SendByte(0x91);           // 发送器件地址及控制位（读）
                I2C_WaitAck();
              
                ucAdc = I2C_RecvByte();       // 接收ADC值
                I2C_SendAck(1);
                I2C_Stop();
              
                return ucAdc;
              }
              // PCF8591 DAC: ucDac-DAC值
              void PCF8591_Dac(unsigned char ucDac)
              {
                I2C_Start();
                I2C_SendByte(0x90);            // 发送器件地址及控制位（写）
                I2C_WaitAck();
              
                I2C_SendByte(0x40);            // 发送控制字（允许DAC）
                I2C_WaitAck();
              
                I2C_SendByte(ucDac);           // 发送DAC值
                I2C_WaitAck();
                I2C_Stop();
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    290    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.56.0.0   I2C                                                               01/25/2025 07:31:09 PAGE 4   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
