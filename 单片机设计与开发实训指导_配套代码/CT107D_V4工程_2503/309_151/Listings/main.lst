C51 COMPILER V9.56.0.0   MAIN                                                              01/25/2025 16:34:08 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEFINE(PCF8591) DEBUG 
                    -OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "tim.h"
   2          #include "seg.h"
   3          #include <stdio.h>
   4          #include "key.h"
   5          #include "ds1302.h"
   6          #include "i2c.h"
   7          
   8          unsigned int  uiSec;                // 秒值
   9          unsigned char ucState;              // 系统状态
  10          unsigned int  uiFreq;               // 频率测量值
  11            signed int  siFreq;               // 频率值
  12          unsigned int  uiPF=2000;            // 超限参数
  13            signed int  siCL;                 // 校准参数
  14          unsigned int  uiFmax;               // 频率最大值
  15          unsigned char pucRtc[3];            // 实时时钟值
  16          unsigned char ucTmax[3];            // 频率最大实时时钟值
  17          
  18          void Seg_Proc(void);
  19          void Key_Proc(void);
  20          void Led_Proc(void);
  21          void Data_Proc(void);
  22          // 主函数
  23          void main(void)
  24          {
  25   1        Close_Peripheral();
  26   1        T1_Init();
  27   1        T0_Init();
  28   1        DS1302_SetRtc(pucRtc);            // 设置RTC时钟
  29   1      
  30   1        while (1)
  31   1        {
  32   2          Seg_Proc();
  33   2          Key_Proc();
  34   2          Led_Proc();
  35   2          Data_Proc();
  36   2        }
  37   1      }
  38          
  39          unsigned char pucSeg_Char[12];      // 显示字符
  40          unsigned char pucSeg_Code[8];       // 显示代码
  41          unsigned char ucSeg_Pos;            // 显示位置
  42          unsigned int  uiSeg_Dly;            // 显示刷新延时
  43          unsigned char ucSeg_Dly;            // 显示移位延时
  44          void Seg_Proc(void)
  45          {
  46   1        if (uiSeg_Dly > 300)              // 300ms刷新1次
  47   1        {
  48   2          uiSeg_Dly = 0;
  49   2      
  50   2          switch (ucState)
  51   2          {
  52   3            case 0:                       // 频率界面
  53   3              if (siFreq < 0)
  54   3                sprintf(pucSeg_Char, "F     LL");
C51 COMPILER V9.56.0.0   MAIN                                                              01/25/2025 16:34:08 PAGE 2   

  55   3              else
  56   3                sprintf(pucSeg_Char, "F  %5u", siFreq);
  57   3              break;
  58   3            case 0x10:                    // 超限参数界面
  59   3              sprintf(pucSeg_Char, "P1  %4u", uiPF);
  60   3              break;
  61   3            case 0x11:                    // 校准参数界面
  62   3              sprintf(pucSeg_Char, "P2  %4d", siCL);
  63   3              break;
  64   3            case 0x20:                    // 时间界面
  65   3              sprintf(pucSeg_Char, "%02x-%02x-%02x",
  66   3                (int)pucRtc[0], (int)pucRtc[1], (int)pucRtc[2]);
  67   3              break;
  68   3            case 0x30:                    // 频率回显界面
  69   3              sprintf(pucSeg_Char, "HF %5u", uiFmax);
  70   3              break;
  71   3            case 0x31:                    // 时间回显界面
  72   3              sprintf(pucSeg_Char, "HA%02x%02x%02x",
  73   3                (int)ucTmax[0], (int)ucTmax[1], (int)ucTmax[2]);
  74   3          }
  75   2          Seg_Tran(pucSeg_Char, pucSeg_Code);
  76   2        }
  77   1        if (ucSeg_Dly >= 2)               // 2ms移位1次
  78   1        {
  79   2          ucSeg_Dly = 0;
  80   2      
  81   2          Seg_Disp(pucSeg_Code[ucSeg_Pos], ucSeg_Pos);
  82   2          ucSeg_Pos = ++ucSeg_Pos & 7;    // 数码管循环显示
  83   2        }
  84   1      }
  85          
  86          unsigned char ucKey_Old;            // 旧键值
  87          unsigned char ucKey_Dly;            // 按键刷新延时
  88          void Key_Proc(void)
  89          {
  90   1        unsigned char ucKey_Dn;           // 按下键值
  91   1      
  92   1        if (ucKey_Dly < 10)               // 延时10ms消抖
  93   1          return;
  94   1        ucKey_Dly = 0;
  95   1      
  96   1        ucKey_Dn = Key_Read();            // 键值读取
  97   1        if (ucKey_Dn != ucKey_Old)        // 键值变化
  98   1        {
  99   2          ucKey_Old = ucKey_Dn;
 100   2        } else {
 101   2          ucKey_Dn = 0;
 102   2        }
 103   1      
 104   1        switch (ucKey_Dn)
 105   1        {
 106   2          case 4:                         // S4按键按下
 107   2            ucState &= 0xf0;              // 清除次状态
 108   2            ucState += 0x10;              // 修改主状态
 109   2            if (ucState >= 0x40)
 110   2              ucState = 0;
 111   2            break;
 112   2          case 5:                         // S5按键按下
 113   2            if ((ucState&0x10) != 0)      // 参数或回显界面
 114   2              ucState ^= 1;               // 修改次状态
 115   2            break;
 116   2          case 8:                         // S8按键按下
C51 COMPILER V9.56.0.0   MAIN                                                              01/25/2025 16:34:08 PAGE 3   

 117   2            switch (ucState)
 118   2            {
 119   3              case 0x10:                  // 超限参数
 120   3                if (uiPF < 9000)
 121   3                  uiPF += 1000;
 122   3                break;
 123   3              case 0x11:                  // 校准参数
 124   3                if (siCL < 900)
 125   3                  siCL += 100;
 126   3            }
 127   2            break;
 128   2          case 9:                         // S9按键按下
 129   2            switch (ucState)
 130   2            {
 131   3              case 0x10:                  // 超限参数
 132   3                if (uiPF > 1000)
 133   3                  uiPF -= 1000;
 134   3                break;
 135   3              case 0x11:                  // 校准参数
 136   3                if (siCL > -900)
 137   3                  siCL -= 100;
 138   3            }
 139   2        }
 140   1      }
 141          
 142          unsigned char ucLed;                // LED值
 143          unsigned char ucLed_Dly;            // LED闪烁延时
 144          void Led_Proc(void)
 145          {
 146   1        if (ucLed_Dly < 200)              // 200ms刷新1次
 147   1          return;
 148   1        ucLed_Dly = 0;
 149   1      
 150   1        if (ucState == 0)                 // 频率界面
 151   1          ucLed ^= 1;                     // L1翻转
 152   1        else
 153   1          ucLed &= ~1;                    // L1熄灭
 154   1      
 155   1        if (siFreq < 0)                   // 负频率
 156   1          ucLed |= 2;                     // L2点亮
 157   1        else if (siFreq < uiPF)
 158   1          ucLed &= ~2;                    // L2熄灭
 159   1        else
 160   1          ucLed ^= 2;                     // L2翻转
 161   1        Led_Disp(ucLed);                  // LED显示状态
 162   1      }
 163          
 164          unsigned int  uiData_Dly;           // 数据刷新延时
 165          void Data_Proc(void)
 166          {
 167   1        unsigned long ulDac;              // DAC输出值
 168   1      
 169   1        if (uiData_Dly < 100)             // 100ms刷新1次
 170   1          return;
 171   1        uiData_Dly = 0;
 172   1      
 173   1        DS1302_GetRtc(pucRtc);
 174   1      
 175   1        if (uiFreq > 31867)
 176   1          return;
 177   1      
 178   1        siFreq = uiFreq + siCL;
C51 COMPILER V9.56.0.0   MAIN                                                              01/25/2025 16:34:08 PAGE 4   

 179   1        if ((siFreq > 0) && (siFreq > uiFmax))
 180   1        {
 181   2          uiFmax = siFreq;
 182   2          ucTmax[0] = pucRtc[0];
 183   2          ucTmax[1] = pucRtc[1];
 184   2          ucTmax[2] = pucRtc[2];
 185   2        }
 186   1        if (siFreq < 0)
 187   1          ulDac = 0;
 188   1        else if (siFreq < 500)
 189   1          ulDac = 51;                     // 1V
 190   1        else if (siFreq > uiPF)
 191   1          ulDac = 255;                    // 5V
 192   1        else
 193   1        {
 194   2          ulDac = siFreq*4+uiPF-2500;
 195   2          ulDac *= 51;
 196   2          ulDac /= uiPF-500;
 197   2        }
 198   1        PCF8591_Dac(ulDac);
 199   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    769    ----
   CONSTANT SIZE    =     69    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     49       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
