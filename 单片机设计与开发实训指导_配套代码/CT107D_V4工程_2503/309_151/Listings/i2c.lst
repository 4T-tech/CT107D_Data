C51 COMPILER V9.56.0.0   I2C                                                               01/25/2025 16:34:09 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\Objects\i2c.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\Driver\i2c.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEFINE(PCF859
                    -1) DEBUG OBJECTEXTEND PRINT(.\Listings\i2c.lst) TABS(2) OBJECT(.\Objects\i2c.obj)

line level    source

   1          #define DELAY_TIME 5
   2          // I2C引脚定义
   3          sfr  P2 = 0xA0;
   4          sbit SCL = P2^0;                // 时钟线
   5          sbit SDA = P2^1;                // 数据线
   6          
   7          void I2C_Delay(unsigned char i)
   8          {
   9   1        while(i--);
  10   1      }
  11          // I2C起始条件
  12          void I2C_Start(void)
  13          {
  14   1        SDA = 1;
  15   1        SCL = 1;
  16   1        I2C_Delay(DELAY_TIME);
  17   1        SDA = 0;
  18   1        I2C_Delay(DELAY_TIME);
  19   1      }
  20          // I2C停止条件
  21          void I2C_Stop(void)
  22          {
  23   1        SDA = 0;
  24   1        SCL = 1;
  25   1        I2C_Delay(DELAY_TIME);
  26   1        SDA = 1;
  27   1        I2C_Delay(DELAY_TIME);
  28   1      }
  29          // I2C发送应答：0-应答，1-非应答
  30          void I2C_SendAck(bit bAck)
  31          {
  32   1        SCL = 0;
  33   1        SDA = bAck;
  34   1        I2C_Delay(DELAY_TIME);
  35   1        SCL = 1;
  36   1        I2C_Delay(DELAY_TIME);
  37   1        SCL = 0; 
  38   1        SDA = 1;
  39   1        I2C_Delay(DELAY_TIME);
  40   1      }
  41          // I2C等待应答
  42          bit I2C_WaitAck(void)
  43          {
  44   1        bit bAck;
  45   1      
  46   1        SCL  = 1;
  47   1        I2C_Delay(DELAY_TIME);
  48   1        bAck = SDA;
  49   1        SCL = 0;
  50   1        I2C_Delay(DELAY_TIME);
  51   1        return bAck;
  52   1      }
  53          // I2C发送数据
  54          void I2C_SendByte(unsigned char ucData)
C51 COMPILER V9.56.0.0   I2C                                                               01/25/2025 16:34:09 PAGE 2   

  55          {
  56   1        unsigned char i;
  57   1      
  58   1        for (i=0; i<8; i++)
  59   1        {
  60   2          SCL  = 0;
  61   2          I2C_Delay(DELAY_TIME);
  62   2          if (ucData & 0x80)
  63   2            SDA  = 1;
  64   2          else
  65   2            SDA  = 0;
  66   2          I2C_Delay(DELAY_TIME);
  67   2          SCL = 1;
  68   2          ucData <<= 1;
  69   2          I2C_Delay(DELAY_TIME);
  70   2        }
  71   1        SCL  = 0;
  72   1      }
  73          // I2C接收数据
  74          unsigned char I2C_RecvByte(void)
  75          {
  76   1        unsigned char i, ucData;
  77   1      
  78   1        for (i=0; i<8; i++)
  79   1        {
  80   2          SCL = 1;
  81   2          I2C_Delay(DELAY_TIME);
  82   2          ucData <<= 1;
  83   2          if (SDA)
  84   2            ucData |= 1;
  85   2          SCL = 0;
  86   2          I2C_Delay(DELAY_TIME);
  87   2        }
  88   1        return ucData;
  89   1      }
  90          #ifdef AT24C02
              // AT24C02缓存器写：pucBuf-数据，ucAddr-地址，ucNum-数量
              void AT24C02_WriteBuffer(unsigned char *pucBuf,
                unsigned char ucAddr, unsigned char ucNum)
              {
                I2C_Start();
                I2C_SendByte(0xa0);           // 发送器件地址及控制位（写）
                I2C_WaitAck();
              
                I2C_SendByte(ucAddr);         // 发送数据地址
                I2C_WaitAck();
              
                while (ucNum--)
                {
                  I2C_SendByte(*pucBuf++);    // 发送数据
                  I2C_WaitAck();
                  I2C_Delay(200);
                }
                I2C_Stop();
              }
              // AT24C02缓存器读：pucBuf-数据，ucAddr-地址，ucNum-数量
              void AT24C02_ReadBuffer(unsigned char *pucBuf,
                unsigned char ucAddr, unsigned char ucNum)
              {
                I2C_Start();
                I2C_SendByte(0xa0);           // 发送器件地址及控制位（写）
                I2C_WaitAck();
C51 COMPILER V9.56.0.0   I2C                                                               01/25/2025 16:34:09 PAGE 3   

              
                I2C_SendByte(ucAddr);         // 发送数据地址
                I2C_WaitAck();
              
                I2C_Start();
                I2C_SendByte(0xa1);         // 发送器件地址及控制位（读）
                I2C_WaitAck();
              
                while (ucNum--)
                {
                  *pucBuf++ = I2C_RecvByte();     // 接收数据
                  if (ucNum)
                    I2C_SendAck(0);
                  else
                    I2C_SendAck(1);
                }
                I2C_Stop();
              }
              #endif
 136          #ifdef PCF8591
 137          // PCF8591 ADC：ucAin-ADC通道（0~3），返回值-ADC值
 138          unsigned char PCF8591_Adc(unsigned char ucAin)
 139          {
 140   1        unsigned char ucAdc;
 141   1      
 142   1        I2C_Start();
 143   1        I2C_SendByte(0x90);           // 发送器件地址及控制位（写）
 144   1        I2C_WaitAck();
 145   1      
 146   1        I2C_SendByte(ucAin + 0x40); // 发送控制字（ADC通道，允许DAC）
 147   1        I2C_WaitAck();
 148   1      
 149   1        I2C_Start();
 150   1        I2C_SendByte(0x91);           // 发送器件地址及控制位（读）
 151   1        I2C_WaitAck();
 152   1      
 153   1        ucAdc = I2C_RecvByte();       // 接收ADC值
 154   1        I2C_SendAck(1);
 155   1        I2C_Stop();
 156   1      
 157   1        return ucAdc;
 158   1      }
 159          // PCF8591 DAC: ucDac-DAC值
 160          void PCF8591_Dac(unsigned char ucDac)
 161          {
 162   1        I2C_Start();
 163   1        I2C_SendByte(0x90);            // 发送器件地址及控制位（写）
 164   1        I2C_WaitAck();
 165   1      
 166   1        I2C_SendByte(0x40);            // 发送控制字（允许DAC）
 167   1        I2C_WaitAck();
 168   1      
 169   1        I2C_SendByte(ucDac);           // 发送DAC值
 170   1        I2C_WaitAck();
 171   1        I2C_Stop();
 172   1      }
 173          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    220    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.56.0.0   I2C                                                               01/25/2025 16:34:09 PAGE 4   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
