C51 COMPILER V9.56.0.0   MAIN                                                              01/24/2025 19:01:10 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEFINE(AT24C02,PCF8591
                    -) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "tim.h"
   2          #include "seg.h"
   3          #include <stdio.h>
   4          #include "key.h"
   5          #include "i2c.h"
   6          
   7          unsigned int  uiTms;                // 毫秒值
   8          unsigned int  uiSec;                // 秒值
   9          unsigned char ucState;              // 系统状态
  10          unsigned int  uiAdc;                // ADC值（*100）
  11          unsigned char ucVp_Val;             // 电压参数值（*10）
  12          unsigned char ucVp_Old;             // 电压参数旧值（*10）
  13          unsigned char ucVp_Cnt;             // 计数值
  14          unsigned int  uiVp_Sec;             // 计数计时值
  15          
  16          void Seg_Proc(void);
  17          void Key_Proc(void);
  18          void Led_Proc(void);
  19          void Data_Proc(void);
  20          
  21          void main(void)
  22          { 
  23   1        Close_Peripheral();
  24   1        T1_Init();
  25   1      
  26   1        AT24C02_ReadBuffer((unsigned char*)&ucVp_Val, 0, 1);
  27   1        if ((ucVp_Val > 50) || ((ucVp_Val % 5) != 0))
  28   1          ucVp_Val = 25;                  // 参数越界处理
  29   1      
  30   1        uiAdc = PCF8591_Adc(3) / 0.51;    // 500/255
  31   1        if(uiAdc > (ucVp_Val*10))         // 初始状态处理
  32   1          ucVp_Old = 0;
  33   1        else
  34   1          ucVp_Old = 1;
  35   1      
  36   1        while(1)
  37   1        {
  38   2          Seg_Proc();
  39   2          Key_Proc();
  40   2          Led_Proc();
  41   2          Data_Proc();
  42   2        }
  43   1      }
  44          
  45          unsigned char pucSeg_Char[12];      // 显示字符
  46          unsigned char pucSeg_Code[8];       // 显示代码
  47          unsigned char ucSeg_Pos;            // 显示位置
  48          unsigned int  uiSeg_Dly;            // 显示刷新延时
  49          unsigned char ucSeg_Dly;            // 显示移位延时
  50          void Seg_Proc(void)
  51          {
  52   1        if (uiSeg_Dly > 300)              // 300ms刷新1次
  53   1        {
  54   2          uiSeg_Dly = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              01/24/2025 19:01:10 PAGE 2   

  55   2      
  56   2          switch (ucState)
  57   2          {
  58   3            case 0:                       // 数据界面
  59   3              sprintf(pucSeg_Char, "U    %3.2f", uiAdc/100.0);
  60   3              break;
  61   3            case 1:                       // 参数界面
  62   3              sprintf(pucSeg_Char, "P    %3.2f", ucVp_Val/10.0);
  63   3              break;
  64   3            case 2:                       // 计数界面
  65   3              sprintf(pucSeg_Char, "N%7u", (int)ucVp_Cnt);
  66   3          }
  67   2          Seg_Tran(pucSeg_Char, pucSeg_Code);
  68   2        }
  69   1        if (ucSeg_Dly >= 2)               // 2ms移位1次
  70   1        {
  71   2          ucSeg_Dly = 0;
  72   2      
  73   2          Seg_Disp(pucSeg_Code[ucSeg_Pos], ucSeg_Pos);
  74   2          ucSeg_Pos = ++ucSeg_Pos & 7;    // 数码管循环显示
  75   2        }
  76   1      }
  77          
  78          unsigned char ucKey_Old;            // 旧键值
  79          unsigned char ucKey_Dly;            // 按键刷新延时
  80          unsigned char ucKey_Cnt;            // 按键计数
  81          void Key_Proc(void)
  82          {
  83   1        unsigned char ucKey_Dn;           // 按下键值
  84   1      
  85   1        if(ucKey_Dly < 10)                // 延时10ms消抖
  86   1          return;
  87   1        ucKey_Dly = 0;
  88   1      
  89   1        ucKey_Dn = Key_Read();            // 键值读取
  90   1        if (ucKey_Dn != ucKey_Old)        // 键值变化
  91   1        {
  92   2          ucKey_Old = ucKey_Dn;
  93   2        } else {
  94   2          ucKey_Dn = 0;
  95   2        }
  96   1      
  97   1        switch (ucKey_Dn)
  98   1        {
  99   2          case 12:                        // S12按键
 100   2            if(++ucState == 3)            // 切换显示
 101   2              ucState = 0;
 102   2            if(ucState == 2)              // 离开参数界面，保存参数
 103   2              AT24C02_WriteBuffer((unsigned char*)&ucVp_Val, 0, 1);
 104   2            ucKey_Cnt = 0;
 105   2            break;
 106   2          case 13:                        // S13按键
 107   2            if(ucState == 2)              // 计数界面
 108   2            {
 109   3              ucVp_Cnt = 0;               // 清零计数
 110   3              ucKey_Cnt = 0;
 111   3            }
 112   2            else
 113   2              ucKey_Cnt++;
 114   2            break;
 115   2          case 16:                        // S16按键
 116   2            if(ucState == 1)              // 参数界面
C51 COMPILER V9.56.0.0   MAIN                                                              01/24/2025 19:01:10 PAGE 3   

 117   2            {
 118   3              ucVp_Val += 5;              // 参数增加
 119   3              if(ucVp_Val >= 55)
 120   3                ucVp_Val = 0;
 121   3              ucKey_Cnt = 0;
 122   3            }
 123   2            else
 124   2              ucKey_Cnt++;
 125   2            break;
 126   2          case 17:                        // S17按键
 127   2            if(ucState == 1)
 128   2            {
 129   3              if(ucVp_Val == 0)           // 参数范围：0~5V
 130   3                ucVp_Val = 55;
 131   3              ucVp_Val -= 5;              // 参数减少
 132   3              ucKey_Cnt = 0;
 133   3            }
 134   2            else
 135   2              ucKey_Cnt++;
 136   2        }
 137   1      }
 138          
 139          unsigned char ucLed;                // LED值
 140          void Led_Proc(void)
 141          {
 142   1        if(((uiSec - uiVp_Sec) > 5) && (ucVp_Old == 1))
 143   1          ucLed |= 1;                     // L1点亮
 144   1        else
 145   1          ucLed &= 0xfe;                  // L1熄灭
 146   1      
 147   1        if((ucVp_Cnt & 1) == 1)
 148   1          ucLed |= 2;                     // L2点亮
 149   1        else
 150   1          ucLed &= 0xfd;                  // L2熄灭
 151   1      
 152   1        if(ucKey_Cnt >= 3)
 153   1          ucLed |= 4;                     // L3点亮
 154   1        else
 155   1          ucLed &= 0xfb;                  // L3熄灭
 156   1      
 157   1        Led_Disp(ucLed);
 158   1      }
 159          
 160          unsigned char ucData_Dly;           // 数据采集延时
 161          void Data_Proc(void)
 162          {
 163   1        unsigned char ucVp_Key;
 164   1      
 165   1        if(ucData_Dly < 100)
 166   1          return;
 167   1        ucData_Dly = 0;
 168   1      
 169   1        uiAdc = PCF8591_Adc(3) / 0.51;    // 500/255
 170   1        if((uiAdc / 10) > ucVp_Val)
 171   1          ucVp_Key = 0;
 172   1        else
 173   1          ucVp_Key = 1;
 174   1      
 175   1        if(ucVp_Key != ucVp_Old)
 176   1        {
 177   2          ucVp_Old = ucVp_Key;
 178   2          if(ucVp_Key == 1)
C51 COMPILER V9.56.0.0   MAIN                                                              01/24/2025 19:01:10 PAGE 4   

 179   2          {
 180   3            ucVp_Cnt++;
 181   3            uiVp_Sec = uiSec; 
 182   3          }
 183   2        }
 184   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    559    ----
   CONSTANT SIZE    =     27    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     41       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
